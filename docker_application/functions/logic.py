import numpy as np
import logging


class SimpleAppLogic:
    @staticmethod
    def _clean_input_data_points(data_points_str):
        """
        Given a string of data points separated by `;` split and convert each valid tuple in (x,y) data point
        Ex: '1,2;-1,7;3.4,5.7' ->  [(1, 2), (-1,7), (3.4, 5.7) ]
        """
        data_point_x = []
        data_point_y = []
        data_points_list = data_points_str.split(';')
        for index, data_point_str in zip(range(len(data_points_list)), data_points_list):
            data = data_point_str.split(',')
            if len(data) == 2:
                try:
                    x, y = float(data[0]), float(data[1])
                    data_point_x.append(x), data_point_y.append(y)
                except:
                    logging.warning(f'Data Point {index + 1} ({data}) is not valid!')
            else:
                logging.warning(f'Data Point {index + 1} ({data}) does not have a (x,y) value pair')
        return data_point_x, data_point_y

    @staticmethod
    def fit_input_data(data_points_str, fit_degree, n_fit_points=50):
        """
        Given a string of data points separated by `;` and a `fit_degree` polynomial degree:
        - Convert the data into 2 lists of points, with the  x and y coordinates;
        - Fit a curve the input data and requested degree;
        - Return a list of points generated by the fit;
        """
        x, y = SimpleAppLogic._clean_input_data_points(data_points_str)
        # Fit data
        coefs = np.polyfit(x, y, fit_degree)
        # Generate data points to plot the function fit
        x_min, x_max = np.min(x) - 3, np.max(x) + 3
        x_fit = np.linspace(start=x_min, stop=x_max, num=n_fit_points)
        y_fit = np.poly1d(coefs)(x_fit)
        return x, y, x_fit, y_fit
